#!/usr/bin/env python3
"""Cerebros Dashboard (Prototype)

A lightweight Tkinter dashboard to monitor Cerebros random search runs and
visualize key hyperdense connectivity concepts (p_lateral_connection intensity).

Features (MVP):
- Load a Cerebros project directory (expects oracle.csv accumulating trial results)
- Auto-refresh KPIs (best metric, trials, last trial metric, avg metric)
- Plot metric over time (matplotlib embedded)
- Visualize expected lateral multiplicity curve 位_k = 位 * decay(k) for chosen intensity & decay
- Inspect best model summary (loaded lazily to avoid blocking UI)
- Safe background thread for model actions to keep UI responsive

Planned Extensions:
- Live tail of active search log
- Graph export visualization (open HTML / JSON spec)
- Connectivity multiplicity empirical histogram (instrumented run)
- Parameter tweaking + quick sampling sandbox

Usage:
  python cerebros_dashboard.py --project some_project_folder

Author: (auto-generated by assistant)
"""
from __future__ import annotations

import argparse
import threading
import queue
import time
import os
import sys
import math
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from dataclasses import dataclass
from typing import Optional, List, Callable, Any

import numpy as np
import pandas as pd
import matplotlib
# Use interactive TkAgg backend for smoother real-time updates (only update on main thread)
matplotlib.use("TkAgg")
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401
from matplotlib import cm

# Import Cerebros pieces lazily where practical to reduce import latency
try:
    from cerebros.denseautomlstructuralcomponent.dense_automl_structural_component import (
        zero_95_exp_decay,
        zero_7_exp_decay,
        DenseLateralConnectivity,
    )
except Exception:  # pragma: no cover - soft fail for environment sanity
    zero_95_exp_decay = lambda x: 0.95 ** x  # type: ignore
    zero_7_exp_decay = lambda x: 0.7 ** x    # type: ignore
    DenseLateralConnectivity = None  # type: ignore

DEFAULT_DECAY_FN_NAME = "zero_95_exp_decay"
DECAY_FUNCTIONS = {
    "zero_95_exp_decay": zero_95_exp_decay,
    "zero_7_exp_decay": zero_7_exp_decay,
    "none (位 constant)": (lambda x: 1.0),
}

DEFAULT_REFRESH_SECONDS = 3.0
MAX_K_FOR_INTENSITY_PLOT = 12

@dataclass
class KPIs:
    best: float = math.nan
    last: float = math.nan
    avg: float = math.nan
    trials: int = 0


class CerebrosDashboard:
    def __init__(self, root: tk.Tk, project_dir: Optional[str] = None, refresh_seconds: float = DEFAULT_REFRESH_SECONDS, cpu_only: bool = False, show_logo: bool = True, logo_path: Optional[str] = None):
        # ---- Core state ----
        self.root = root
        self.root.title("Cerebros Dashboard (Prototype)")
        self.project_dir = project_dir
        self.oracle_csv: Optional[str] = None
        self.metric_col_guess: Optional[str] = None
        self.stop_event = threading.Event()
        self.refresh_seconds = max(0.3, float(refresh_seconds))  # guard against too small
        self.cpu_only = cpu_only
        self.show_logo = show_logo
        self.logo_path = logo_path
        # Queue of callables to execute on main thread (UI safe)
        self.queue: "queue.Queue[Callable[[], None]]" = queue.Queue()

        # ---- Optional: force TensorFlow to CPU to avoid long GPU JIT / PTX issues ----
        if self.cpu_only:
            try:
                if 'tensorflow' in sys.modules:
                    import tensorflow as tf  # type: ignore
                    try:
                        tf.config.set_visible_devices([], 'GPU')
                    except Exception:
                        pass
                else:
                    os.environ.setdefault('CUDA_VISIBLE_DEVICES', '-1')
                os.environ.setdefault('TF_CPP_MIN_LOG_LEVEL', '2')
            except Exception:
                pass

        # ---- Build UI & kick off periodic tasks ----
        self._build_ui()
        self._schedule_queue_pump()
        if project_dir:
            self._load_project(project_dir)
        self._schedule_refresh()

    # ---------------- UI BUILD -----------------
    def _build_ui(self):
        """Build static UI elements (top bar, controls, notebook)."""
        # Window geometry & close handler
        self.root.geometry("1100x750")
        self.root.protocol("WM_DELETE_WINDOW", self._on_close)

        # ---------- Unified Light Theme (white background) ----------
        # Force a known theme, then override key style elements to white so gray defaults disappear.
        try:
            style = ttk.Style()
            # Some platforms may already use a modern theme; clam is reliably styleable.
            try:
                style.theme_use('clam')
            except Exception:
                pass
            # Generic background for most widgets
            for element in ['TFrame', 'TLabelframe', 'TLabelframe.Label', 'TLabel', 'TNotebook', 'TNotebook.Tab']:
                try:
                    style.configure(element, background='white')
                except Exception:
                    pass
            # Root window background (affects areas not covered by frames)
            self.root.configure(bg='white')
        except Exception:
            pass

        # Top bar container
        top = ttk.Frame(self.root)
        top.pack(fill="x", padx=8, pady=6)

        # Optional logo + tagline (kept small)
        if self.show_logo:
            self._load_logo_image()
            logo_img = getattr(self, 'logo_image', None)
            if logo_img is not None:
                logo_box = ttk.Frame(top)
                logo_box.pack(side="left", padx=(0,12))
                ttk.Label(logo_box, image=logo_img, borderwidth=0).pack(side="top")
                # Heuristic: suppress tagline if the logo likely already includes word mark
                logo_file = (self._selected_logo_path or '').lower() if hasattr(self, '_selected_logo_path') else ''
                if not any(x in logo_file for x in ("cerebros.png", "cerebros_logo_simple", "0-cerebros-logo")):
                    style = ttk.Style()
                    try:
                        style.configure("Tagline.TLabel", font=("Segoe UI", 9, "italic"), foreground="#4A6C8A", background='white')
                    except Exception:  # pragma: no cover
                        pass
                    ttk.Label(logo_box, text="One world, one family, one algorithm", style="Tagline.TLabel").pack(side="top")

        # Project / demo buttons
        ttk.Button(top, text="Open Project...", command=self._pick_project).pack(side="left")
        ttk.Button(top, text="Load Demo (Ames)", command=self._create_demo_ames_project).pack(side="left", padx=4)
        self.project_label_var = tk.StringVar(value="No project loaded")
        ttk.Label(top, textvariable=self.project_label_var).pack(side="left", padx=12)

        # Intensity controls block (right side)
        ctrl = ttk.Labelframe(top, text="Lateral Intensity Explorer")
        ctrl.pack(side="right", padx=4)
        self.lambda_var = tk.DoubleVar(value=1.5)
        ttk.Label(ctrl, text="位 (p_lateral_connection)").grid(row=0, column=0, sticky="w")
        tk.Spinbox(
            ctrl,
            from_=0.0,
            to=10.0,
            increment=0.1,
            textvariable=self.lambda_var,
            width=6,
            command=self._update_intensity_plot,
        ).grid(row=0, column=1)
        ttk.Label(ctrl, text="Decay").grid(row=0, column=2, padx=(10, 2))
        self.decay_choice = tk.StringVar(value=DEFAULT_DECAY_FN_NAME)
        ttk.Combobox(
            ctrl,
            values=list(DECAY_FUNCTIONS.keys()),
            state="readonly",
            textvariable=self.decay_choice,
            width=16,
        ).grid(row=0, column=3)
        ttk.Button(ctrl, text="Update", command=self._update_intensity_plot).grid(row=0, column=4, padx=6)

        # Notebook for tabs
        self.nb = ttk.Notebook(self.root)
        self.nb.pack(fill="both", expand=True, padx=6, pady=4)
        self._init_tabs()

    # ---------------- Assets -----------------
    def _load_logo_image(self):
        """Attempt to load a small logo image; shrink if needed.

        Priority:
          1. Explicit path provided via --logo
          2. Known candidate asset names in ./assets
        Fails silently (logo optional)."""
        candidates: List[str] = []
        if self.logo_path:
            candidates.append(self.logo_path)
        candidates.extend([
            "assets/cerebros_logo_simple.png",  # newly provided simpler logo
            "assets/0-cerebros-logo.png",
            "assets/Cerebros.png",
            "assets/brain.png",
            "assets/Brain-lookalike1.png",
            "assets/Brain-lookalike2.png",
        ])
        base_dir = os.path.dirname(os.path.abspath(__file__))
        for rel in candidates:
            path = rel if os.path.isabs(rel) else os.path.join(base_dir, rel)
            if os.path.exists(path):
                try:
                    img = tk.PhotoImage(file=path)
                    max_w, max_h = 160, 90
                    factor = max(img.width()/max_w, img.height()/max_h, 1.0)
                    subsample_factor = int(math.ceil(factor))
                    if subsample_factor > 1:
                        img = img.subsample(int(subsample_factor), int(subsample_factor))  # type: ignore[arg-type]
                    self.logo_image = img
                    self._selected_logo_path = path  # remember which one for tagline heuristic
                    return
                except Exception:
                    continue
        self.logo_image = None

    def _init_tabs(self):
        """Create tab frames, add to notebook, build their UI, and init 3D state."""
        self.tab_overview = ttk.Frame(self.nb)
        self.tab_intensity = ttk.Frame(self.nb)
        self.tab_model = ttk.Frame(self.nb)
        self.tab_network3d = ttk.Frame(self.nb)

        self.nb.add(self.tab_overview, text="Overview")
        self.nb.add(self.tab_intensity, text="Intensity Curve")
        self.nb.add(self.tab_model, text="Best Model")
        self.nb.add(self.tab_network3d, text="3D Network (Prototype)")

        # Build tab contents after creation
        self._build_overview_tab()
        self._build_intensity_tab()
        self._build_model_tab()
        self._build_network3d_tab()

        # 3D network state
        self._network3d_model = None
        self._network3d_nodes = None  # dict with coords & scatter ref
        self._network3d_edges = []
        self._network3d_animating = False
        self._network3d_sample_input = None

    def _build_overview_tab(self):
        # KPI row
        kpi_frame = ttk.Frame(self.tab_overview)
        kpi_frame.pack(fill="x", pady=6)
        self.kpi_labels = {}
        for name in ["Best", "Last", "Average", "Trials"]:
            outer = ttk.Frame(kpi_frame, relief="groove", padding=6)
            outer.pack(side="left", expand=True, fill="x", padx=4)
            ttk.Label(outer, text=name, font=("Segoe UI", 10, "bold")).pack(anchor="w")
            var = tk.StringVar(value="-")
            ttk.Label(outer, textvariable=var, font=("Segoe UI", 14)).pack(anchor="w")
            self.kpi_labels[name.lower()] = var

        # Metric timeline plot + selector
        fig = Figure(figsize=(6,3), dpi=100)
        self.metric_fig = fig
        self.metric_ax = fig.add_subplot(111)
        self.metric_canvas = FigureCanvasTkAgg(fig, master=self.tab_overview)
        selector_bar = ttk.Frame(self.tab_overview)
        selector_bar.pack(fill="x", pady=(4,0))
        ttk.Label(selector_bar, text="Metric:").pack(side="left", padx=(4,2))
        self.metric_selector_var = tk.StringVar()
        self.metric_selector = ttk.Combobox(selector_bar, state="readonly", textvariable=self.metric_selector_var, width=32)
        self.metric_selector.pack(side="left")
        self.metric_selector.bind("<<ComboboxSelected>>", self._on_metric_selected)
        self.metric_canvas.get_tk_widget().pack(fill="both", expand=True, pady=(4,0))
        self.metric_ax.set_title("Metric Over Trials (live)")
        self.metric_ax.set_xlabel("Trial")
        self.metric_ax.set_ylabel("Metric")
        self.metric_line = None  # created lazily

    def _build_intensity_tab(self):
        fig = Figure(figsize=(6,4), dpi=100)
        self.intensity_fig = fig
        self.intensity_ax = fig.add_subplot(111)
        self.intensity_canvas = FigureCanvasTkAgg(fig, master=self.tab_intensity)
        self.intensity_canvas.get_tk_widget().pack(fill="both", expand=True)
        self.intensity_ax.set_title("Expected Lateral Multiplicity vs Offset (k)")
        self.intensity_ax.set_xlabel("k (horizontal offset)")
        self.intensity_ax.set_ylabel("E[multiplicity]")
        self._update_intensity_plot(initial=True)

    def _build_model_tab(self):
        top = ttk.Frame(self.tab_model)
        top.pack(fill="x")
        ttk.Button(top, text="Load Best Model Summary", command=self._load_best_model_summary).pack(side="left", padx=4, pady=4)
        self.model_summary_text = tk.Text(self.tab_model, wrap="none", height=30)
        self.model_summary_text.pack(fill="both", expand=True, padx=4, pady=4)
        self.model_summary_text.insert("end", "Click 'Load Best Model Summary' to display model summary...\n")

    # ------------- 3D Network Tab -------------
    def _build_network3d_tab(self):
        controls = ttk.Frame(self.tab_network3d)
        controls.pack(fill="x", pady=4)
        ttk.Button(controls, text="Load From Best Model", command=self._network3d_load_best).pack(side="left", padx=4)
        self.network3d_status = tk.StringVar(value="Model not loaded")
        ttk.Label(controls, textvariable=self.network3d_status).pack(side="left", padx=8)
        ttk.Label(controls, text="Max neurons/layer:").pack(side="left", padx=(12,2))
        self.network3d_max_neurons = tk.IntVar(value=32)
        tk.Spinbox(controls, from_=4, to=256, increment=4, textvariable=self.network3d_max_neurons, width=6, command=self._network3d_relayout).pack(side="left")
        ttk.Button(controls, text="Toggle Animate", command=self._network3d_toggle_animate).pack(side="right", padx=4)
        ttk.Button(controls, text="One Step", command=self._network3d_step).pack(side="right", padx=4)

        fig = Figure(figsize=(6.5,4.8), dpi=100)
        self.network3d_fig = fig
        self.network3d_ax = fig.add_subplot(111, projection='3d')
        self.network3d_canvas = FigureCanvasTkAgg(fig, master=self.tab_network3d)
        self.network3d_canvas.get_tk_widget().pack(fill="both", expand=True)
        self.network3d_ax.set_title("3D Network (Dense Layers Only)")
        self.network3d_ax.set_xlabel("Layer")
        self.network3d_ax.set_ylabel("Neuron Index")
        self.network3d_ax.set_zlabel("Activation")

    def _network3d_load_best(self):
        # Reuse logic from model tab to locate best model path
        if not self.project_dir or not self.oracle_csv:
            messagebox.showwarning("No Project", "Load a project first")
            return
        try:
            df = pd.read_csv(str(self.oracle_csv))
        except Exception as e:
            messagebox.showerror("Read Error", str(e)); return
        if df.empty:
            self.network3d_status.set("oracle.csv empty")
            return
        if self.metric_col_guess not in df.columns:
            self.network3d_status.set("Metric unknown yet")
            return
        metric_series = pd.to_numeric(df[self.metric_col_guess], errors='coerce')
        minimize = self._is_minimize_metric()
        best_idx = metric_series.idxmin() if minimize else metric_series.idxmax()
        model_path_val = df.loc[best_idx, 'model_name'] if 'model_name' in df.columns else None
        if model_path_val is None or (isinstance(model_path_val, float) and math.isnan(model_path_val)):
            self.network3d_status.set("Best model path missing")
            return
        model_path = str(model_path_val)
        if not os.path.exists(model_path):
            self.network3d_status.set("Model file missing")
            return
        try:
            from cerebros.persistence.keras_io import load_model_safe
            model = load_model_safe(model_path)
        except Exception as e:
            self.network3d_status.set(f"Load err: {e}")
            return
        self._network3d_model = model
        self._network3d_prepare_sample()
        self._network3d_build_layout()
        self.network3d_status.set("Loaded & laid out")

    def _network3d_prepare_sample(self):
        model = self._network3d_model
        if model is None:
            return
        input_shape = model.input_shape
        # input_shape like (None, n) or list
        if isinstance(input_shape, list):
            input_shape = input_shape[0]
        if input_shape is None or len(input_shape) < 2:
            n_features = 16
        else:
            n_features = int(input_shape[1])
        # Create stable sample reused for animation
        rng = np.random.default_rng(1337)
        self._network3d_sample_input = rng.normal(0, 1, size=(1, n_features)).astype('float32')

    def _network3d_dense_layers(self):
        model = self._network3d_model
        if model is None:
            return []
        dense_layers = []
        for layer in model.layers:
            class_name = layer.__class__.__name__.lower()
            if 'dense' in class_name and hasattr(layer, 'units'):
                dense_layers.append(layer)
        return dense_layers

    def _network3d_build_layout(self):
        layers = self._network3d_dense_layers()
        if not layers:
            self.network3d_ax.clear()
            self.network3d_ax.text(0.5,0.5,0.5,"No dense layers", ha='center')
            self.network3d_canvas.draw_idle()
            return
        max_per = int(self.network3d_max_neurons.get())
        xs=[]; ys=[]; zs=[]; colors=[]; layer_offsets=[]
        layer_index=0
        for layer in layers:
            units = getattr(layer, 'units', 0)
            display = min(units, max_per)
            # Simple vertical arrangement; y indices 0..display-1
            for i in range(display):
                xs.append(layer_index)
                ys.append(i)
                zs.append(0.0)  # activation placeholder
                colors.append(0.0)
            layer_offsets.append((layer_index, display))
            layer_index += 1
        self._network3d_nodes = {
            'xs': np.array(xs, dtype=float),
            'ys': np.array(ys, dtype=float),
            'zs': np.array(zs, dtype=float),
            'colors': np.array(colors, dtype=float),
            'layer_meta': layer_offsets,
        }
        self._network3d_edges = self._network3d_make_edges(layer_offsets)
        self._network3d_draw(initial=True)

    def _network3d_make_edges(self, layer_offsets):
        # Build sparse edges between adjacent layers (fan-in fully but capped for clarity)
        edges = []
        cap = 32  # limit edges density
        for idx in range(len(layer_offsets)-1):
            l_from, n_from = layer_offsets[idx]
            l_to, n_to = layer_offsets[idx+1]
            use_from = min(n_from, cap)
            use_to = min(n_to, cap)
            for i in range(use_from):
                for j in range(use_to):
                    edges.append(((l_from, i, 0.0), (l_to, j, 0.0)))
        return edges

    def _network3d_draw(self, initial=False):
        if self._network3d_nodes is None:
            return
        ax = self.network3d_ax
        if initial:
            ax.clear()
            ax.set_title("3D Network (Dense Layers Only)")
            ax.set_xlabel("Layer")
            ax.set_ylabel("Neuron")
            ax.set_zlabel("Activation")
            # Draw edges lightly
            for (x1,y1,z1),(x2,y2,z2) in self._network3d_edges:
                ax.plot([x1,x2],[y1,y2],[z1,z2], color='#999999', alpha=0.15, linewidth=0.5)
            norm_colors = self._network3d_nodes['colors']
            cmap = cm.get_cmap('viridis')
            mapped = cmap((norm_colors - norm_colors.min() + 1e-9)/(norm_colors.ptp()+1e-9))
            self._network3d_nodes['scatter'] = ax.scatter(self._network3d_nodes['xs'], self._network3d_nodes['ys'], self._network3d_nodes['zs'], c=mapped, s=18, depthshade=False)
        else:
            scatter = self._network3d_nodes.get('scatter')
            if scatter is not None:
                norm_colors = self._network3d_nodes['colors']
                cmap = cm.get_cmap('viridis')
                mapped = cmap((norm_colors - norm_colors.min() + 1e-9)/(norm_colors.ptp()+1e-9))
                scatter._facecolor3d = mapped
                scatter._edgecolor3d = mapped
        # Adjust Z limit to current activation range
        c = self._network3d_nodes['colors']
        zmin = float(np.min(c))
        zmax = float(np.max(c))
        if zmax - zmin < 1e-6:
            zmax = zmin + 1.0
        ax.set_zlim(zmin, zmax)
        self.network3d_canvas.draw_idle()

    def _network3d_step(self):
        model = self._network3d_model
        if model is None or self._network3d_nodes is None:
            return
        try:
            # Forward pass to capture activations
            # Build a sub-model per dense layer to get outputs
            sample = self._network3d_sample_input
            if sample is None:
                self._network3d_prepare_sample()
                sample = self._network3d_sample_input
            dense_layers = self._network3d_dense_layers()
            activ_arrays = []
            x = sample
            for layer in dense_layers:
                x = layer(x)  # functional call (layers are callable)
                act = x.numpy() if hasattr(x, 'numpy') else np.array(x)
                activ_arrays.append(act)
        except Exception as e:
            self.network3d_status.set(f"Fwd err: {e}")
            return
        # Map activations into node color (take first row, trim to displayed neurons)
        colors = self._network3d_nodes['colors']
        offset = 0
        max_per = int(self.network3d_max_neurons.get())
        for acts in activ_arrays:
            row = acts[0]
            use = min(len(row), max_per)
            colors[offset:offset+use] = row[:use]
            offset += use
        # Store activations also as Z
        self._network3d_nodes['zs'] = colors.copy()
        scatter = self._network3d_nodes.get('scatter')
        if scatter is not None:
            scatter._offsets3d = (self._network3d_nodes['xs'], self._network3d_nodes['ys'], self._network3d_nodes['zs'])
        self._network3d_draw(initial=False)

    def _network3d_toggle_animate(self):
        self._network3d_animating = not self._network3d_animating
        if self._network3d_animating:
            self.network3d_status.set("Animating...")
            self._network3d_anim_loop()
        else:
            self.network3d_status.set("Paused")

    def _network3d_anim_loop(self):
        if not self._network3d_animating:
            return
        self._network3d_step()
        # Schedule next frame (adjust for performance)
        self.root.after(800, self._network3d_anim_loop)

    def _network3d_relayout(self):
        if self._network3d_model is None:
            return
        self._network3d_build_layout()

    # ------------- Project / Data Handling -------------
    def _pick_project(self):
        d = filedialog.askdirectory()
        if d:
            self._load_project(d)

    def _load_project(self, d: str):
        oracle = os.path.join(d, "oracle.csv")
        if not os.path.exists(oracle):
            messagebox.showerror("Not a Cerebros project", f"oracle.csv not found in {d}")
            return
        self.project_dir = d
        self.oracle_csv = oracle
        self.project_label_var.set(f"Project: {os.path.basename(d)}")
        self._refresh_metrics()

    # ------------- Metrics refresh -------------
    def _schedule_refresh(self):
        if not self.stop_event.is_set():
            self.root.after(int(self.refresh_seconds * 1000), self._refresh_metrics)

    def _refresh_metrics(self):
        oracle_path = self.oracle_csv
        if oracle_path and os.path.exists(oracle_path):
            try:
                df = pd.read_csv(oracle_path)
            except Exception:
                self._schedule_refresh()
                return
            if df.empty:
                self._schedule_refresh(); return
            # Detect metric column if not known: prefer columns starting with 'val_' or ending metric strings
            # Update metric selector options if columns changed / first load
            numeric_cols = [c for c in df.columns if pd.api.types.is_numeric_dtype(df[c])]
            if numeric_cols:
                self._sync_metric_selector(numeric_cols)

            if (self.metric_col_guess not in df.columns) and numeric_cols:
                candidates = [c for c in df.columns if c.startswith('val_')]
                if not candidates:
                    # fallback choose last numeric
                    candidates = numeric_cols[-1:] if numeric_cols else []
                self.metric_col_guess = candidates[0] if candidates else None
                if self.metric_col_guess and (not self.metric_selector_var.get()):
                    self.metric_selector_var.set(self.metric_col_guess)
            if self.metric_col_guess:
                series = pd.to_numeric(df[self.metric_col_guess], errors='coerce').dropna()
                if not series.empty:
                    kpis = KPIs(
                        best=(series.min() if self._is_minimize_metric() else series.max()),
                        last=series.iloc[-1],
                        avg=series.mean(),
                        trials=len(series),
                    )
                    self._update_kpis(kpis)
                    self._update_metric_plot(series)
        self._schedule_refresh()

    def _is_minimize_metric(self) -> bool:
        # Heuristic: if metric contains 'loss' or 'error' -> minimize
        if not self.metric_col_guess:
            return True
        name = self.metric_col_guess.lower()
        return any(x in name for x in ("loss", "error", "rmse", "mae"))

    def _update_kpis(self, k: KPIs):
        self.kpi_labels["best"].set(self._fmt_float(k.best))
        self.kpi_labels["last"].set(self._fmt_float(k.last))
        self.kpi_labels["average"].set(self._fmt_float(k.avg))
        self.kpi_labels["trials"].set(str(k.trials))

    def _update_metric_plot(self, series: pd.Series):
        # Real-time style incremental update (avoid full clear for less flicker)
        x_vals = np.arange(1, len(series)+1)
        y_vals = series.to_numpy(dtype=float)
        label = self.metric_col_guess or "metric"
        if self.metric_line is None or self.metric_line.get_label() != label:
            self.metric_ax.cla()
            self.metric_line, = self.metric_ax.plot(x_vals, y_vals, marker="o", linewidth=1.2, label=label)
            self.metric_ax.set_xlabel("Trial")
            self.metric_ax.set_ylabel(label)
            self.metric_ax.grid(alpha=0.25)
        else:
            self.metric_line.set_data(x_vals, y_vals)
        self.metric_ax.relim()
        self.metric_ax.autoscale_view()
        # Keep a little headroom on y axis
        ymin, ymax = self.metric_ax.get_ylim()
        if np.isfinite(ymin) and np.isfinite(ymax) and ymax > ymin:
            pad = 0.05 * (ymax - ymin)
            self.metric_ax.set_ylim(ymin - pad*0.2, ymax + pad)
        self.metric_canvas.draw_idle()

    def _sync_metric_selector(self, numeric_cols: List[str]):
        """Ensure metric selector combobox options match provided numeric columns."""
        existing = list(self.metric_selector.cget('values')) if self.metric_selector else []
        if set(existing) != set(numeric_cols):
            self.metric_selector['values'] = numeric_cols
        # Keep current selection if valid
        current = self.metric_selector_var.get()
        if current and current in numeric_cols:
            return
        # Else choose first val_ column, else first numeric
        preferred = [c for c in numeric_cols if c.startswith('val_')]
        chosen = preferred[0] if preferred else (numeric_cols[0] if numeric_cols else '')
        if chosen:
            self.metric_selector_var.set(chosen)
            self.metric_col_guess = chosen

    def _on_metric_selected(self, _event):
        sel = self.metric_selector_var.get()
        if sel:
            self.metric_col_guess = sel
            # Reset line so labels update cleanly on next refresh
            self.metric_line = None

    # ------------- Demo Project Generation -------------
    def _create_demo_ames_project(self):
        """Create a lightweight demo project with a synthetic oracle.csv (and a simple model) so the UI has something to display.

        Strategy:
          - Create ./demo_ames_project (or reuse existing)
          - If TensorFlow available: build a tiny Dense model (input_dim inferred from ames.csv columns if present, else 20)
          - Save model to best_model.keras
          - Create oracle.csv with a few synthetic trial rows (val_loss decreasing) pointing to the saved model path
          - Load that project into the dashboard.
        """
        base_dir = os.path.abspath("demo_ames_project")
        os.makedirs(base_dir, exist_ok=True)
        model_path = os.path.join(base_dir, "best_model.keras")
        # Try to build a small model (optional)
        built_model = False
        input_dim = 20
        ames_csv = os.path.join(os.getcwd(), "ames.csv")
        if os.path.exists(ames_csv):
            try:
                df_ames = pd.read_csv(ames_csv)
                # pick some numeric columns
                num_cols = [c for c in df_ames.columns if pd.api.types.is_numeric_dtype(df_ames[c])]
                if num_cols:
                    input_dim = min(len(num_cols), 30)
            except Exception:
                pass
        try:
            import tensorflow as tf  # type: ignore
            from tensorflow import keras  # type: ignore
            inp = keras.Input(shape=(input_dim,), name="features")
            x = keras.layers.Dense(32, activation='relu')(inp)
            x = keras.layers.Dense(16, activation='relu')(x)
            out = keras.layers.Dense(1, activation='linear', name='price')(x)
            model = keras.Model(inp, out)
            model.compile(optimizer='adam', loss='mse')
            # Train briefly on random data to get non-trivial weights
            rng = np.random.default_rng(42)
            X = rng.normal(size=(64, input_dim)).astype('float32')
            y = rng.normal(size=(64, 1)).astype('float32')
            model.fit(X, y, epochs=2, verbose=0)
            try:
                # Use persistence helper if available else fallback to model.save
                try:
                    from cerebros.persistence.keras_io import save_model_safe  # type: ignore
                    save_model_safe(model, model_path)
                except Exception:
                    model.save(model_path)
                built_model = True
            except Exception as e:  # pragma: no cover
                print(f"Demo model save failed: {e}")
        except Exception:
            pass  # TensorFlow not available; continue with synthetic rows only

        # Create synthetic oracle.csv
        rows = []
        # Simulate 6 trials with improving val_loss
        val_losses = [1.20, 0.95, 0.80, 0.72, 0.70, 0.69]
        for i, vl in enumerate(val_losses, start=1):
            rows.append({
                'trial': i,
                'val_loss': vl,
                'loss': vl + 0.05,  # pretend training loss is slightly higher
                'model_name': model_path if built_model else ''
            })
        df = pd.DataFrame(rows)
        oracle_csv = os.path.join(base_dir, 'oracle.csv')
        df.to_csv(oracle_csv, index=False)
        self._load_project(base_dir)
        # Pre-select val_loss metric
        self.metric_col_guess = 'val_loss'
        self.metric_selector_var.set('val_loss')
        messagebox.showinfo("Demo Ready", f"Demo project created at {base_dir}")

    # ------------- Intensity Visualization -------------
    def _update_intensity_plot(self, initial: bool=False):
        lam = max(0.0, float(self.lambda_var.get()))
        decay_fn = DECAY_FUNCTIONS.get(self.decay_choice.get(), lambda x: 1.0)
        ks = np.arange(0, MAX_K_FOR_INTENSITY_PLOT + 1)
        expected = [lam * decay_fn(k) for k in ks]
        self.intensity_ax.clear()
        bars = self.intensity_ax.bar(ks, expected, color="#3A7AFE")
        for rect, val in zip(bars, expected):
            self.intensity_ax.text(rect.get_x()+rect.get_width()/2, rect.get_height()+0.05,
                                   f"{val:.2f}", ha='center', va='bottom', fontsize=8)
        self.intensity_ax.set_ylim(0, max(expected)*1.15 + 0.1)
        self.intensity_ax.set_xlabel("k (offset)")
        self.intensity_ax.set_ylabel("E[multiplicity]")
        self.intensity_ax.set_title("Expected Lateral Multiplicity Curve")
        self.intensity_ax.grid(alpha=0.3)
        self.intensity_canvas.draw_idle()

    # ------------- Model Summary -------------
    def _load_best_model_summary(self):
        if not self.project_dir:
            messagebox.showwarning("No Project", "Load a project first")
            return
        # Determine best model path from oracle
        try:
            df = pd.read_csv(str(self.oracle_csv))  # type: ignore[arg-type]
        except Exception as e:
            messagebox.showerror("Read Error", str(e)); return
        if df.empty:
            messagebox.showinfo("Empty", "oracle.csv is empty yet")
            return
        if self.metric_col_guess not in df.columns:
            messagebox.showerror("Metric Unknown", "Metric column not inferred yet. Wait for refresh.")
            return
        metric_series = pd.to_numeric(df[self.metric_col_guess], errors='coerce')
        if metric_series.isna().all():
            messagebox.showerror("No Metrics", "Metric column has no numeric values yet")
            return
        minimize = self._is_minimize_metric()
        best_idx = metric_series.idxmin() if minimize else metric_series.idxmax()
        model_path_val: Any = df.loc[best_idx, 'model_name'] if 'model_name' in df.columns else None
        # Normalize to string path
        model_path: Optional[str]
        if model_path_val is None or (isinstance(model_path_val, float) and math.isnan(model_path_val)):
            model_path = None
        else:
            model_path = str(model_path_val)
        if not model_path or not os.path.exists(model_path):
            messagebox.showerror("Missing Model", f"Model path not found or inaccessible: {model_path}")
            return
        # Load summary in thread
        self.model_summary_text.delete('1.0', 'end')
        self.model_summary_text.insert('end', f"Loading model summary from {model_path}...\n")
        t = threading.Thread(target=self._thread_load_model_summary, args=(model_path,))
        t.daemon = True
        t.start()

    def _thread_load_model_summary(self, model_path: str):
        try:
            from cerebros.persistence.keras_io import load_model_safe
            model = load_model_safe(model_path)
            out_lines = []
            model.summary(print_fn=lambda s: out_lines.append(s))
            text = "\n".join(out_lines)
        except Exception as e:  # pragma: no cover - runtime path
            text = f"Error loading model: {e}"
        self.queue.put(lambda: self._display_model_summary(text))

    def _display_model_summary(self, text: str):
        self.model_summary_text.delete('1.0', 'end')
        self.model_summary_text.insert('end', text + '\n')

    # ------------- Queue / Close -------------
    def _schedule_queue_pump(self):
        try:
            while True:
                cb = self.queue.get_nowait()
                cb()
        except queue.Empty:
            pass
        self.root.after(150, self._schedule_queue_pump)

    def _on_close(self):
        self.stop_event.set()
        self.root.destroy()

    # ------------- Helpers -------------
    @staticmethod
    def _fmt_float(x: float) -> str:
        if math.isnan(x):
            return "-"
        if abs(x) >= 1000 or abs(x) < 1e-3:
            return f"{x:.3e}"
        return f"{x:.4f}".rstrip('0').rstrip('.')


def main(argv: Optional[List[str]] = None):
    parser = argparse.ArgumentParser(description="Cerebros Dashboard")
    parser.add_argument('--project', type=str, help='Path to Cerebros project directory containing oracle.csv')
    parser.add_argument('--refresh', type=float, default=DEFAULT_REFRESH_SECONDS, help='UI refresh interval seconds (>=0.3)')
    parser.add_argument('--cpu-only', action='store_true', help='Force TensorFlow to run on CPU (disables GPU visibility)')
    parser.add_argument('--no-logo', action='store_true', help='Hide logo / tagline (minimal UI)')
    parser.add_argument('--logo', type=str, help='Explicit path to logo image (overrides assets autodetect)')
    args = parser.parse_args(argv)

    root = tk.Tk()
    CerebrosDashboard(root,
                      project_dir=args.project,
                      refresh_seconds=args.refresh,
                      cpu_only=args.cpu_only,
                      show_logo=not args.no_logo,
                      logo_path=args.logo)
    root.mainloop()


if __name__ == '__main__':
    main()
